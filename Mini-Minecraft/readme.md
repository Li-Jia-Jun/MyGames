# **<p align="center">L-system Mini-Minecraft Log</p>**

## 12/07/2021  Milestone3 ##

## **Zhuohao Lin:**
### **Milestone3 Features:**

Features implemented:

1.	Additional biomes: island and desert (previous biomes: grassland and mountain)
2.	Procedurally placed assets: 2 types of trees with varying heights are procedurally placed in both grassland and island biomes. The distribution of trees is also different in 2 biomes.
3.	Water waves with distorted surface and corresponding normal displacement.
4.	Better Postprocess effect when player is under water

Difficulties:

1.	Making island biome look like an actual island.
Solution: I use fractal 2-dimensional Perlin as the height map of island biome. Then I use smoothstep() function to adjust the slope of the terrain, so that water can have more depth.
2.	Remove sharp borders between biomes
Solution: There are sharp borders between biomes when I generate biomes based on temperature and moisture (2 different noises). I did not find a way to remove sharp borders by modifying temperature and moisture. Instead, I use the same blocks for island and grassland to hide the border.
3.	Tree canopies will be cut when trees are generated at the edge of chunks. In our implementation, the neighbor chunk may not be created yet when a tree is generated, so I cannot set leaf block at the neighbor chunk.
Solution: I move trees inward when trees are placed at the edge of chunks so that leaf blocks are always set within a single chunk.


## **Jiajun Li:**
### **Milestone3 Features:**

Features implemented:

1.	Game time. Define game time in the program. Set the default time scale as 144 so that 10 minutes in real life equals to 24 hours of game time.
2.	Procedural sky and day night cycle. Use ray cast method to draw the sky and sky elements. Sun and moon move according to game time (For example, in 0 am in game time, sun is right beneath player; in 12 am, sun is right on top of the player). Also define 5-7 AM as sunrise time and 5-7 PM as sunset time. During sunrise and sunset, sky fragments close to horizon blend into orange and red. Sky base color also changes according to game time. During night time, use simple noise function to draw stars. Moreover, sun light direction in lambert shader change according to sun direction of the sky.
3.	Cloud. Cloud is a huge quad (1024x1024) that lays on top of the player and moves with player. Apply a high-resolution texture to the quad. Also add some UV animations so that player can see the cloud moving.
4.	Weather system. Define several weather states such as rain and golden rain. Use ratio to control rain effect so that rain can first builds up (ratio 0 - 1), fully falls (ratio stays 1) and fades out (ratios 1 - 0). Rain elements have billboard effect. Also adjust distance fog and sky color so that the whole scene will look grey and gloom.
5.	Particle system. In player's third person flight mode, create golden particles that sparks in the opposite direction of player's velocity and fades out during lifetime. Particle elements also have billboard effect.
6.	Tree shade. Inspired by lights in Minecraft, simply define that grass block is in tree shade if there is any leaf block on top. The method works in this program because tree is the only element that is expected to cast some shadow.

Difficulties:

1.	To allow cloud plane follow player every tick.
Solution: Create a cloud plane VBO based on player's position and pass position offset to shader as uniform so that we don't need to destroying and creating VBO every tick.
2.	To create a billboard shader.  
Solution: Pass view matrix and projection matrix to shader separately and erase the rotation part of the view matrix. In this way no rotation will apply to object and the object will obtain its facing direction.
3.	To manage particles in particle system.  
Solution: Create an object pool to store all particles. When we need to create a new particle, get it from the pool. When particle expires its life time, put it back to pool. In this way we can reuse particles instead of destroying and creating particles from time to time.


## **Haoquan Liang:**
### **Milestone3 Features:**

Features implemented:
1.	.obj model and texture loader
2.	NPC: Bird, Rabbit, Zombie, Eagle, Human, Robot, Deer. They all have different set of animation and movement pattern. They can all detect obstacles and react to it. 
3.	NPC: Piggy that deforms itself and always chases the player
4.	L-System string generator, parser, and terrain re-writer. The maze is generated by giving it the grammar. 
5.	Procedurally placed NPCs (only birds are procedurally placed for now)
6.	Third-person mode
7.	Special player and camera movement for cinematic shot
8.	Special animation for flight mode
9.	Riding the deer when the player is 3 blocks away from it, and deer when stay where the player dismount it
10.	In-game sounds include footstep when walking, rain sound when it rains, and earthquake sound when the world tree is “growing”


Difficulties:

1.	NPC animation is not easy to make
Solution: instead of building scene graphs and having to make the model pieces separately and import them separately, I used the shader to do the trick. I just pass the bounding box to the shader, and transform according to the proportions of the NPC parts
2.	Third-person mode camera requires some math
Solution: although it’s similar to the spherical camera, but it has translations and some rotations from the first-person mode. I reset some properties of the camera every time it’s switched.
3.	Procedurally placing NPCs may cause data race
Solution: since I’m not doing instanced rendering for the NPCs, procedurally placing NPCs in the chunk workers might cause data race. So, I placed it in the main thread and it will place NPCs every time a chunk worked is spawned.

